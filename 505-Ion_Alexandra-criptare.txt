--CRIPTAREA DATELOR

--Datele de salarizare din tabelul ANGAJAT (salariu, data_angajarii), cat și datele personale din tabelele ANGAJAT, CLIENȚI și FURNIZORI (email, telefon) vor fi criptate utilizând algoritmul de criptare AES- 128, padding PAD_PKCS5 și  metoda de chaining CHAIN_CBC.
--Cheile de criptare private vor fi generate automat, pe 16 bytes, și stocate în baza de date, în tabelul CHEI_CRIPTARE(id_cheie#, cheie, tabel). De asemenea, se va utiliza o secventa pentru generarea cheii primare.
-- S-au creat functiile pentru decriptare ce vor fi utilizate pentru a decripta si afisa datele din ANGAJATI

create table CHEI_CRIPTARE(
    id_cheie int,
    cheie raw(128),
    tabel varchar2(50)
);

CREATE SEQUENCE SEQ_CHEI_CRIPTARE
    START WITH 1
    INCREMENT BY 1;
    

----------------
create or replace procedure CRIPTARE_ANGAJATI (
    p_nume varchar2,
    p_prenume varchar2,
    p_job varchar2,
    p_telefon varchar2,
    p_salariu number,
    p_data_angajarii date,
    p_aplicatie  varchar2,
    p_id_manager  varchar2
) is
    mod_op pls_integer := dbms_crypto.encrypt_aes128 + dbms_crypto.pad_pkcs5 + dbms_crypto.chain_cbc;
    cheie raw(128) := dbms_crypto.randombytes(16);
    salariu_current raw(128);
    data_angajarii_current raw(128);
    telefon_current raw(128);
    
    -- Funcția de criptare pentru numere
    function encrypt_number(atr number, cheie raw) return raw is
    begin
        return dbms_crypto.encrypt(
            utl_i18n.string_to_raw(to_char(atr), 'AL32UTF8'),
            mod_op,
            cheie
        );
    end;

    -- Funcția de criptare pentru date
    function encrypt_date(atr date, cheie raw) return raw is
    begin
        return dbms_crypto.encrypt(
            utl_i18n.string_to_raw(to_char(atr, 'YYYY-MM-DD HH24:MI:SS'), 'AL32UTF8'),
            mod_op,
            cheie
        );
    end;

    -- Funcția de criptare pentru șiruri
    function encrypt_string(atr varchar2, cheie raw) return raw is
    begin
        return dbms_crypto.encrypt(
            utl_i18n.string_to_raw(atr, 'AL32UTF8'),
            mod_op,
            cheie
        );
    end;
begin
   -- Verifică dacă cheia există deja
    declare
        v_exists number;
    begin
        select count(*) into v_exists
        from chei_criptare
        where tabel = 'ANGAJATI';

        -- Dacă cheia nu există, o adaugă în tabel
        if v_exists = 0 then
            cheie := dbms_crypto.randombytes(16);
             insert into chei_criptare values (SEQ_CHEI_CRIPTARE.nextval, cheie, 'ANGAJATI');
        else
            -- Dacă cheia există, o preia din tabel
            select cheie into cheie
            from chei_criptare
            where tabel = 'ANGAJATI';
        end if;
    end;

    -- Criptează datele
    salariu_current := encrypt_number(p_salariu, cheie);
    data_angajarii_current := encrypt_date(p_data_angajarii, cheie);
    telefon_current := encrypt_string(p_telefon, cheie);


INSERT INTO ANGAJATI VALUES (NEXT_ID_ANGAJATI.NEXTVAL, p_nume,p_prenume,p_job,telefon_current,salariu_current, data_angajarii_current, p_aplicatie, p_id_manager);

    commit;
end;
/


BEGIN
    CRIPTARE_ANGAJATI(
        p_nume        => 'Ion',
        p_prenume     => 'Loredana',
        p_job         => 'executant',
        p_telefon     => '0245222162',
        p_salariu     => 1500,
        p_data_angajarii => TO_DATE('10-05-2021', 'dd-mm-yyyy'),
        p_aplicatie   => NULL,
        p_id_manager  => NULL
    );
        CRIPTARE_ANGAJATI(
        p_nume => 'Andreescu',
        p_prenume => 'Daiana',
        p_job => 'proiectant',
        p_telefon => '0745222163',
        p_salariu => 1800,
        p_data_angajarii => to_date('09-01-2010', 'dd-mm-yyyy'),
        p_aplicatie => 'Fusion360',
        p_id_manager => 100
    );

    CRIPTARE_ANGAJATI(
        p_nume => 'Ramond',
        p_prenume => 'Liliana',
        p_job => 'agent',
        p_telefon => '0745228182',
        p_salariu => 3000,
        p_data_angajarii => to_date('14-06-2019', 'dd-mm-yyyy'),
        p_aplicatie => NULL,
        p_id_manager => 101
    );

    CRIPTARE_ANGAJATI(
        p_nume => 'Flo',
        p_prenume => 'Luis',
        p_job => 'proiectant',
        p_telefon => '0245552168',
        p_salariu => 4500,
        p_data_angajarii => to_date('25-05-2018', 'dd-mm-yyyy'),
        p_aplicatie => 'Creo',
        p_id_manager => 101
    );

    CRIPTARE_ANGAJATI(
        p_nume => 'Dan',
        p_prenume => 'Cornelia',
        p_job => 'proiectant',
        p_telefon => '0243722175',
        p_salariu => 1500,
        p_data_angajarii => to_date('11-08-2019', 'dd-mm-yyyy'),
        p_aplicatie => 'Fusion360',
        p_id_manager => 101
    );

    CRIPTARE_ANGAJATI(
        p_nume => 'Remus',
        p_prenume => 'Denis',
        p_job => 'executant',
        p_telefon => '0245722196',
        p_salariu => 6500,
        p_data_angajarii => to_date('10-05-2015', 'dd-mm-yyyy'),
        p_aplicatie => NULL,
        p_id_manager => 101
    );

    CRIPTARE_ANGAJATI(
        p_nume => 'Ion',
        p_prenume => 'Gabriel',
        p_job => 'agent',
        p_telefon => '0712125866',
        p_salariu => 3000,
        p_data_angajarii => to_date('14-06-2020', 'dd-mm-yyyy'),
        p_aplicatie => NULL,
        p_id_manager => 101
    );

    commit;
END;
/
select * from angajati;

select * from chei_criptare;


----------------
create or replace procedure CRIPTARE_CLIENTI (
    p_nume varchar2,
    p_prenume varchar2,
    p_telefon varchar2,
    p_email  varchar2

) is
    mod_op pls_integer := dbms_crypto.encrypt_aes128 + dbms_crypto.pad_pkcs5 + dbms_crypto.chain_cbc;
    cheie raw(128) := dbms_crypto.randombytes(16);
    email_current raw(128);
    telefon_current raw(128);
    
    function encrypt_string(atr varchar2, cheie raw) return raw is
    begin
        return dbms_crypto.encrypt(
            utl_i18n.string_to_raw(atr, 'AL32UTF8'),
            mod_op,
            cheie
        );
    end;
begin
   -- Verifică dacă cheia există deja
    declare
        v_exists number;
    begin
        select count(*) into v_exists
        from chei_criptare
        where tabel = 'CLIENTI';

        -- Dacă cheia nu există, o adaugă în tabel
        if v_exists = 0 then
            cheie := dbms_crypto.randombytes(16);
             insert into chei_criptare values (SEQ_CHEI_CRIPTARE.nextval, cheie, 'CLIENTI');
        else
            -- Dacă cheia există, o preia din tabel
            select cheie into cheie
            from chei_criptare
            where tabel = 'CLIENTI';
        end if;
    end;

    -- Criptează datele
    telefon_current := encrypt_string(p_telefon, cheie);
    email_current := encrypt_string(p_email, cheie);


INSERT INTO CLIENTI VALUES (NEXT_ID_CLIENTI.NEXTVAL, p_nume,p_prenume,telefon_current, email_current);

    commit;
end;
/


BEGIN
    CRIPTARE_CLIENTI(
        p_nume        => 'Ion',
        p_prenume     => 'Alexandra',
        p_telefon     => '0728282106',
        p_email       => 'alexion200123@yahoo.com'
    );

    CRIPTARE_CLIENTI(
        p_nume        => 'Dinu',
        p_prenume     => 'Cristian',
        p_telefon     => '0724702608',
        p_email       => 'dinuc02@yahoo.com'
    );

    CRIPTARE_CLIENTI(
        p_nume        => 'Vulpe',
        p_prenume     => 'Catalin',
        p_telefon     => '0785212833',
        p_email       => 'vulpea69@gmail.com'
    );

    CRIPTARE_CLIENTI(
        p_nume        => 'Dinca',
        p_prenume     => 'Ruxandra',
        p_telefon     => '0721283488',
        p_email       => 'ruxi23@yahoo.com'
    );

    CRIPTARE_CLIENTI(
        p_nume        => 'Rotaru',
        p_prenume     => 'Cristina',
        p_telefon     => '0700569254',
        p_email       => 'cristina_rotaru32@yahoo.com'
    );

    CRIPTARE_CLIENTI(
        p_nume        => 'Iacob',
        p_prenume     => 'Andreea',
        p_telefon     => '0721385065',
        p_email       => 'icob_andreea@yahoo.com'
    );
    
END;
/

select * from clienti;

select * from chei_criptare;

–exemplu de utilizare a funcțiilor pentru decriptare

SELECT 
    a.ID_ANGAJAT,
    a.NUME,
    a.PRENUME,
    a.JOB,
    decrypt_str(a.TELEFON, c.CHEIE) AS TELEFON,
    decrypt_number(a.SALARIU, c.CHEIE) AS SALARIU,
    decrypt_date(a.DATA_ANGAJARII, c.CHEIE) AS DATA_ANGAJARII,
    a.APLICATIE,
    a.ID_MANAGER
FROM 
    ANGAJATI a
JOIN 
    CHEI_CRIPTARE c ON c.TABEL = 'ANGAJATI'  -- Assuming 'TABEL' in CHEI_CRIPTARE identifies the table
WHERE
    c.TABEL = 'ANGAJATI';





CREATE OR REPLACE FUNCTION decrypt_str(atr RAW, cheie RAW) RETURN VARCHAR2 IS
    mod_op PLS_INTEGER := DBMS_CRYPTO.ENCRYPT_AES128 + DBMS_CRYPTO.PAD_PKCS5 + DBMS_CRYPTO.CHAIN_CBC;
    decrypted_value VARCHAR2(32767);
BEGIN
    decrypted_value := TO_CHAR(UTL_I18N.RAW_TO_CHAR(
        DBMS_CRYPTO.DECRYPT(
            atr,
            mod_op,
            cheie
        ),
        'AL32UTF8'
    ));
    RETURN decrypted_value;
END;
/

CREATE OR REPLACE FUNCTION decrypt_number(atr RAW, cheie RAW) RETURN NUMBER IS
    mod_op PLS_INTEGER := DBMS_CRYPTO.ENCRYPT_AES128 + DBMS_CRYPTO.PAD_PKCS5 + DBMS_CRYPTO.CHAIN_CBC;
BEGIN
    RETURN TO_NUMBER(UTL_I18N.RAW_TO_CHAR(
        DBMS_CRYPTO.DECRYPT(
            atr,
            mod_op,
            cheie
        ),
        'AL32UTF8'
    ));
END;
/


CREATE OR REPLACE FUNCTION decrypt_date(atr RAW, cheie RAW) RETURN DATE IS
    mod_op PLS_INTEGER := DBMS_CRYPTO.ENCRYPT_AES128 + DBMS_CRYPTO.PAD_PKCS5 + DBMS_CRYPTO.CHAIN_CBC;
BEGIN
    RETURN TO_DATE(UTL_I18N.RAW_TO_CHAR(
        DBMS_CRYPTO.DECRYPT(
            atr,
            mod_op,
            cheie
        ),
        'AL32UTF8'
    ), 'YYYY-MM-DD HH24:MI:SS');
END;
/
